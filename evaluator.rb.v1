class EvaluatorException <StandardError
end


#class EvaluatorValue
#  attr :line_values
#  attr :value_names
#  attr :value
#end


class Evaluator
  # evaluate recurse and smart
  attr_accessor :line_values
  attr_accessor :value_names
  attr_accessor :value
  attr_accessor :type, :name

  # do initialization
  def init(expr)
    p ":: #{expr}."

    if expr.class == Array
      @stack = expr
    else
      #
      @stack = expr.split
    end

    next_op=@stack.shift
    @name=next_op

    case next_op
    when /^s'(\S+)'$/
      # stream name
      @type=:stream
      @file=open($1,"r")
      read_fieldnames
    when 'select'
      @type=:select

      e=Evaluator.new
      e.init(@stack.shift)
#      p "SELECT! #{e} (#{e.type})"
      @select_stream=e

      @select_args = Array.new
      while @stack[0] != ';'
#        p "<<<< #{@stack[0]}"
        e=Evaluator.new
        e.init(@stack)
        @select_args.push e
      end
    when /^min|max|sum$/
      @type=:func
      # 1 arg
      @arg1=Evaluator.new
      @arg1.init(@stack)
      e=Evaluator.new
      e.init(@stack)
      @func_stream = e
    when /^eq|ne|gt|lt$/
      @type=:cond
      # 2 arg
      @arg1=Evaluator.new
      @arg1.init(@stack)
      @arg2=Evaluator.new
      @arg2.init(@stack)
    when /\+|\-|\*|\//
      @type=:operation
      # 2 arg
      @arg1=Evaluator.new
      @arg1.init(@stack)
      @arg2=Evaluator.new
      @arg2.init(@stack)
    when /^'(\S+)'$/
      @type=:string
      @name=$1
    else
      @type=:field
    end
#    p "Created: #{@type}/#{@name} (#{expr})"
  end

  def get_next(cur=nil)
    cur ||= Evaluator.new
    p "Evaluating: #{@type} (#{cur.line_values})"
    result=cur
    case @type
    when :stream
      result.line_values=@file.readline.split(/\s*,\s*/)
      p "read: #{result.line_values}"
      raise IOError if result.line_values.size<@field_names.size
      result.value_names=@field_names
    when :cond, :operation
      a1=@arg1.get_next(cur).value
      a2=@arg2.get_next(cur).value
      result.value=op_evaluate(a1,a2)
    when :func
      a1=@func_stream.get_next(cur).value
#      p "FUNC_STREAM: #{a1}"
      @cur=a1
      next_value=@arg1.get_next(cur).value
#      p "VAL=#{next_value}"
      if @result.nil?
        @result=Evaluator.new
        @result.value=next_value
      else
        @result.value=func_evaluate(next_value)
      end
      result=@result
      begin
        while a1=@func_stream.get_next(cur) do
          p "!FUNC_STREAM: #{a1}"
          next unless a1

          @cur=a1
          next_value=@arg1.get_next(cur).value
          p "!VAL=#{next_value}"
          @result.value=func_evaluate(next_value)
        end
      rescue
      end
      p "?FUNC_STREAM: #{a1}"

    when :field
      @cur=cur
      result.value=read_field(@name)
    when :string
      result.value=@name
    when :select
#      p "SELECT"
      begin
        selection_res=true
        @result=@select_stream.get_next(cur)
#        p "!!!!!!!!!!!! #{@result}"
        @select_args.each { |sel|
          selection_res = selection_res and sel.get_next(cur)
        }
      end until selection_res
    else
      raise EvaluatorException
    end
    cur=result
    p "RET(#{@name}/#{@type}): #{result.value} / #{result.line_values}"
    return result
  end

  def op_evaluate(a1,a2)
    case @name
      when '+'
        a1.to_f+a2.to_f
      when '-'
        a1.to_f-a2.to_f
      when '*'
        a1.to_f*a2.to_f
      when '/'
        a1.to_f/a2.to_f
      when 'eq'
        a1==a2
      when 'ne'
        a1!=a2
      when 'gt'
        a1.to_f>a2.to_f
      when 'lt'
        a1.to_f<a2.to_f
    end
  end

  def func_evaluate(a1)
    case @name
      when 'min'
        @result.value=[a1,@result.value].min
      when 'max'
        p "#{a1} #{@result.value}"
        @result.value=[a1,@result.value].max
      when 'sum'
        @result.value+=a1
    end
  end

  def read_field(name)
    p "Field: #{name} / #{@cur.value_names}}"
    f=@cur.value_names.index(name)
    @cur.line_values[f]
  end

  def get_result
    @result
  end

  def read_fieldnames
    @field_names=@file.readline.split(/\s*,\s*/)
#    names.each_index { |i| @field_name[names[i]]=i; p ":: #{i}: #{names[i]}" }
  end
end


e=Evaluator.new
e.init("min + '1' * - end start np select s'test_stream.csv' gt np '10' ;");
result=e.get_next()
p "Result: #{result.value}"

