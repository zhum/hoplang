class EvaluatorError <StandardError
end

class StreamEvaluator
  # do initialization
  def init(name,expr)
    if expr.class == Array
      stack = expr
    else
      # string
      stack = expr.split
    end

    @name=name

    if @name =~ /^s'(\S+)'$/
      # stream name
      @type=:stream
      @file=open($1,"r")
      read_fieldnames
    else
      raise EvaluatorError "Bad stream name: #{@name}"
    end
  end

  def get_next(cur=Evaluator.new)
    p "Evaluating: #{@type} (#{cur.line_values})"
    result=cur
    result.line_values=@file.readline.split(/\s*,\s*/)
    p "read: #{result.line_values}"
    raise IOError if result.line_values.size<@field_names.size
    result.value_names=@field_names
  end
end

class SelectEvaluator
  def init(name,stack)

    @type=:select

    e=Evaluator.new(stack)
    @select_stream=e
    @select_args = Array.new
    while stack[0] != ';'
      e=Evaluator.new(stack)
      @select_args.push e
    end
  end

  def get_next(cur)
    begin #loop !!!!!!!!!!!!!!!!!!!!!!!!!!
      #TODO:  make full condition
      selection_condition=true
      @result=@select_stream.get_next(cur)
      @select_args.each { |sel|
        selection_condition = selection_condition and sel.get_next(cur)
      }
    end until selection_condition
  end
end

class AgregateFuncEvaluator
  def init(name,stack)
      # args: functions, selection(from stream)
      @func=Evaluator.new(name)
      #TODO: new Stream

      @stream=Evaluator.new(stack)
      #TODO: new selection
  end

  def get_next(cur)
    @result=Evaluator.new
#    @result.value=next_value

    # read next line from stream
#    @cur=@stream.get_next(cur).value
    # compute value
#    next_value=@func.get_next(cur).value

    begin
      while true
        next_value=@stream.get_next(cur).value
        p "!FUNC_STREAM=#{next_value}"
        func_result=@func.get_next(cur)
        p "!FUNC_VAL: #{func_result}"
        redo unless func_result

#        @cur=func_result
        func_evaluate(@result.value,next_value)
      end
    rescue
    end
    p "FUNC_RESULT: #{@result.value}"
    @result
  end

  def func_evaluate(result,next_value)
    case @name
      when 'min'
        result=[next_value,@result].min
      when 'max'
        p "MAX: #{next_value} #{result}"
        result=[next_value,result].max
      when 'sum'
        result+=next_value
    end
  end

end

class ConditionEvaluator

end


class Evaluator
  # evaluate recurse and smart

  attr_reader   :type, :name

  attr_accessor :line_values
  attr_accessor :value_names
  attr_accessor :value

  # do initialization
  def self.new(expr)
    p ":: #{expr}."

    if expr.class == Array
      @stack = expr
    else
      #
      @stack = expr.split
    end

    @name=@stack.shift

    case @name
    when /^s'(\S+)'$/
      ret=StreamEvaluator(@name,@stack)
#      # stream name
#      @type=:stream
#      @file=open($1,"r")
#      read_fieldnames
    when 'select'
      ret=SelectEvaluator(@name,@stack)
#      @type=:select
#
#      e=Evaluator.new
#      e.init(@stack.shift)
##      p "SELECT! #{e} (#{e.type})"
#      @select_stream=e
#
#      @select_args = Array.new
#      while @stack[0] != ';'
##        p "<<<< #{@stack[0]}"
#        e=Evaluator.new
#        e.init(@stack)
#        @select_args.push e
#      end
    when /^min|max|sum$/
#      @type=:func
      # 1 arg
#      @arg1=Evaluator.new
#      @arg1.init(@stack)
      ret=AgregateFuncEvaluator.new(@name,@stack)
#      e.init(@stack)
#      @func_stream = e
    when /^eq|ne|gt|lt$/
      ret=ConditionEvaluator.new(@name,@stack)
#      @type=:cond
#      # 2 arg
#      @arg1=Evaluator.new
#      @arg1.init(@stack)
#      @arg2=Evaluator.new
#      @arg2.init(@stack)
    when /\+|\-|\*|\//
      @type=:operation
      # 2 arg
      @arg1=Evaluator.new
      @arg1.init(@stack)
      @arg2=Evaluator.new
      @arg2.init(@stack)
    when /^'(\S+)'$/
      @type=:string
      @name=$1
    else
      @type=:field
    end
#    p "Created: #{@type}/#{@name} (#{expr})"
  end

  def get_next(cur=nil)
    cur ||= Evaluator.new
    p "Evaluating: #{@type} (#{cur.line_values})"
    result=cur
    case @type
    when :stream
      result.line_values=@file.readline.split(/\s*,\s*/)
      p "read: #{result.line_values}"
      raise IOError if result.line_values.size<@field_names.size
      result.value_names=@field_names
    when :cond, :operation
      a1=@arg1.get_next(cur).value
      a2=@arg2.get_next(cur).value
      result.value=op_evaluate(a1,a2)
    when :func
      a1=@func_stream.get_next(cur).value
#      p "FUNC_STREAM: #{a1}"
      @cur=a1
      next_value=@arg1.get_next(cur).value
#      p "VAL=#{next_value}"
      if @result.nil?
        @result=Evaluator.new
        @result.value=next_value
      else
        @result.value=func_evaluate(next_value)
      end
      result=@result
      begin
        while a1=@func_stream.get_next(cur)
          p "!FUNC_STREAM: #{a1}"
          next unless a1

          @cur=a1
          next_value=@arg1.get_next(cur).value
          p "!VAL=#{next_value}"
          @result.value=func_evaluate(next_value)
        end
      rescue
      end
      p "?FUNC_STREAM: #{a1}"

    when :field
      @cur=cur
      result.value=read_field(@name)
    when :string
      result.value=@name
    when :select
#      p "SELECT"
      begin
        selection_res=true
        @result=@select_stream.get_next(cur)
#        p "!!!!!!!!!!!! #{@result}"
        @select_args.each { |sel|
          selection_res = selection_res and sel.get_next(cur)
        }
      end until selection_res
    else
      raise EvaluatorException
    end
    cur=result
    p "RET(#{@name}/#{@type}): #{result.value} / #{result.line_values}"
    return result
  end

  def op_evaluate(a1,a2)
    case @name
      when '+'
        a1.to_f+a2.to_f
      when '-'
        a1.to_f-a2.to_f
      when '*'
        a1.to_f*a2.to_f
      when '/'
        a1.to_f/a2.to_f
      when 'eq'
        a1==a2
      when 'ne'
        a1!=a2
      when 'gt'
        a1.to_f>a2.to_f
      when 'lt'
        a1.to_f<a2.to_f
    end
  end

  def read_field(name)
    p "Field: #{name} / #{@cur.value_names}}"
    f=@cur.value_names.index(name)
    @cur.line_values[f]
  end

  def get_result
    @result
  end

  def read_fieldnames
    @field_names=@file.readline.split(/\s*,\s*/)
#    names.each_index { |i| @field_name[names[i]]=i; p ":: #{i}: #{names[i]}" }
  end
end


e=Evaluator.new
e.init("min + '1' * - end start np select s'test_stream.csv' gt np '10' ;");
result=e.get_next()
p "Result: #{result.value}"

